import { db } from "@/lib/auth/database";

export type VulnerabilityRecord = {
  id: string;
  title: string;
  severity: string;
  description: string | null;
  observations: string | null;
  remediation: string | null;
  affected: string | null;
  score: number;
};

export type VulnerabilityServerRecord = {
  id: string;
  name: string;
  ip: string;
  environment: string | null;
};

export type VulnerabilityLinkRecord = {
  id: number;
  vulnerability_id: string;
  server_id: string;
  status: "active" | "resolved";
  occurrences: number;
  resolved_count: number;
  first_detected_at: string | null;
  last_changed_at: string | null;
};

export type VulnerabilityEventRecord = {
  id: number;
  vulnerability_id: string;
  server_id: string;
  event_type: "detected" | "resolved" | "reopened";
  event_at: string;
};

export type VulnerabilityRetestRecord = {
  id: number;
  vulnerability_id: string;
  server_id: string;
  status: "requested" | "passed" | "failed";
  requested_at: string;
  retested_at: string | null;
};

export function listVulnerabilities() {
  return db
    .prepare<VulnerabilityRecord>(
      `SELECT id, title, severity, description, observations, remediation, affected, score
       FROM vulnerabilities
       ORDER BY id`
    )
    .all();
}

export function listVulnerabilityServers() {
  return db
    .prepare<VulnerabilityServerRecord>(
      `SELECT id, name, ip, environment
       FROM vulnerability_servers
       ORDER BY id`
    )
    .all();
}

export function listVulnerabilityLinks() {
  return db
    .prepare<VulnerabilityLinkRecord>(
      `SELECT id, vulnerability_id, server_id, status, occurrences, resolved_count,
              first_detected_at, last_changed_at
       FROM vulnerability_links
       ORDER BY vulnerability_id, server_id`
    )
    .all();
}

export function listVulnerabilityEvents() {
  return db
    .prepare<VulnerabilityEventRecord>(
      `SELECT id, vulnerability_id, server_id, event_type, event_at
       FROM vulnerability_link_events
       ORDER BY event_at`
    )
    .all();
}

export function listVulnerabilityRetests() {
  return db
    .prepare<VulnerabilityRetestRecord>(
      `SELECT id, vulnerability_id, server_id, status, requested_at, retested_at
       FROM vulnerability_retests
       ORDER BY requested_at`
    )
    .all();
}

function getVulnerabilityLink(vulnerabilityId: string, serverId: string) {
  return db
    .prepare<VulnerabilityLinkRecord>(
      `SELECT id, vulnerability_id, server_id, status, occurrences, resolved_count,
              first_detected_at, last_changed_at
       FROM vulnerability_links
       WHERE vulnerability_id = ? AND server_id = ?`
    )
    .get(vulnerabilityId, serverId);
}

function getLatestRetest(vulnerabilityId: string, serverId: string) {
  return db
    .prepare<VulnerabilityRetestRecord>(
      `SELECT id, vulnerability_id, server_id, status, requested_at, retested_at
       FROM vulnerability_retests
       WHERE vulnerability_id = ? AND server_id = ?
       ORDER BY requested_at DESC
       LIMIT 1`
    )
    .get(vulnerabilityId, serverId);
}

function getLatestPendingRetest(vulnerabilityId: string, serverId: string) {
  return db
    .prepare<VulnerabilityRetestRecord>(
      `SELECT id, vulnerability_id, server_id, status, requested_at, retested_at
       FROM vulnerability_retests
       WHERE vulnerability_id = ? AND server_id = ? AND status = 'requested'
       ORDER BY requested_at DESC
       LIMIT 1`
    )
    .get(vulnerabilityId, serverId);
}

function ensureVulnerabilityExists(id: string) {
  const row = db
    .prepare<{ total: number }>(
      "SELECT COUNT(*) as total FROM vulnerabilities WHERE id = ?"
    )
    .get(id);
  return (row?.total ?? 0) > 0;
}

function ensureServerExists(id: string) {
  const row = db
    .prepare<{ total: number }>(
      "SELECT COUNT(*) as total FROM vulnerability_servers WHERE id = ?"
    )
    .get(id);
  return (row?.total ?? 0) > 0;
}

export function linkVulnerabilityToServer(
  vulnerabilityId: string,
  serverId: string
) {
  if (!ensureVulnerabilityExists(vulnerabilityId) || !ensureServerExists(serverId)) {
    return null;
  }

  const now = new Date().toISOString();
  const current = getVulnerabilityLink(vulnerabilityId, serverId);
  const insertEvent = db.prepare(
    `INSERT INTO vulnerability_link_events
      (vulnerability_id, server_id, event_type, event_at)
      VALUES (?, ?, ?, ?)`
  );

  if (!current) {
    db.prepare(
      `INSERT INTO vulnerability_links
        (vulnerability_id, server_id, status, occurrences, resolved_count, first_detected_at, last_changed_at)
        VALUES (?, ?, 'active', 1, 0, ?, ?)`
    ).run(vulnerabilityId, serverId, now, now);
    insertEvent.run(vulnerabilityId, serverId, "detected", now);
    return getVulnerabilityLink(vulnerabilityId, serverId);
  }

  if (current.status === "resolved") {
    db.prepare(
      `UPDATE vulnerability_links
       SET status = 'active',
           occurrences = occurrences + 1,
           last_changed_at = ?
       WHERE id = ?`
    ).run(now, current.id);
    insertEvent.run(vulnerabilityId, serverId, "reopened", now);
  }

  return getVulnerabilityLink(vulnerabilityId, serverId);
}

export function resolveVulnerabilityForServer(
  vulnerabilityId: string,
  serverId: string
) {
  const now = new Date().toISOString();
  const current = getVulnerabilityLink(vulnerabilityId, serverId);
  if (!current) {
    return null;
  }
  if (current.status === "resolved") {
    return current;
  }
  db.prepare(
    `UPDATE vulnerability_links
     SET status = 'resolved',
         resolved_count = resolved_count + 1,
         last_changed_at = ?
     WHERE id = ?`
  ).run(now, current.id);
  db.prepare(
    `INSERT INTO vulnerability_link_events
      (vulnerability_id, server_id, event_type, event_at)
      VALUES (?, ?, 'resolved', ?)`
  ).run(vulnerabilityId, serverId, now);
  return getVulnerabilityLink(vulnerabilityId, serverId);
}

export function requestVulnerabilityRetest(
  vulnerabilityId: string,
  serverId: string
) {
  const current = getVulnerabilityLink(vulnerabilityId, serverId);
  if (!current) {
    return null;
  }
  const now = new Date().toISOString();
  db.prepare(
    `INSERT INTO vulnerability_retests
      (vulnerability_id, server_id, status, requested_at)
      VALUES (?, ?, 'requested', ?)`
  ).run(vulnerabilityId, serverId, now);
  return getLatestRetest(vulnerabilityId, serverId);
}

export function completeVulnerabilityRetest(
  vulnerabilityId: string,
  serverId: string,
  result: "passed" | "failed"
) {
  const current = getVulnerabilityLink(vulnerabilityId, serverId);
  if (!current) {
    return null;
  }
  const now = new Date().toISOString();
  const pending = getLatestPendingRetest(vulnerabilityId, serverId);
  if (pending) {
    db.prepare(
      `UPDATE vulnerability_retests
       SET status = ?, retested_at = ?
       WHERE id = ?`
    ).run(result, now, pending.id);
  } else {
    db.prepare(
      `INSERT INTO vulnerability_retests
        (vulnerability_id, server_id, status, requested_at, retested_at)
        VALUES (?, ?, ?, ?, ?)`
    ).run(vulnerabilityId, serverId, result, now, now);
  }

  if (result === "passed") {
    resolveVulnerabilityForServer(vulnerabilityId, serverId);
  }

  return getLatestRetest(vulnerabilityId, serverId);
}

export function listEventsForLink(vulnerabilityId: string, serverId: string) {
  return db
    .prepare<VulnerabilityEventRecord>(
      `SELECT id, vulnerability_id, server_id, event_type, event_at
       FROM vulnerability_link_events
       WHERE vulnerability_id = ? AND server_id = ?
       ORDER BY event_at`
    )
    .all(vulnerabilityId, serverId);
}
