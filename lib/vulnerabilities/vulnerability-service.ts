import { db } from "@/lib/auth/database";
import { getLocalTimestamp } from "@/lib/utils/time";

export type VulnerabilityRecord = {
  id: string;
  title: string;
  severity: string;
  description: string | null;
  observations: string | null;
  remediation: string | null;
  affected: string | null;
  score: number;
  cve?: string | null;
  cpe?: string | null;
  vpr_score?: number | null;
  vpr_updated?: string | null;
  cvss4_base_score?: number | null;
  cvss4_temporal_score?: number | null;
  cvss3_base_score?: number | null;
  cvss3_temporal_score?: number | null;
  cvss_temporal_score?: number | null;
};

export type VulnerabilityServerRecord = {
  id: string;
  name: string;
  ip: string;
  environment: string | null;
  asset_class?: string | null;
};

export type VulnerabilityLinkRecord = {
  id: number;
  vulnerability_id: string;
  server_id: string;
  status: "active" | "resolved";
  occurrences: number;
  resolved_count: number;
  first_detected_at: string | null;
  last_changed_at: string | null;
};

export type VulnerabilityEventRecord = {
  id: number;
  vulnerability_id: string;
  server_id: string;
  event_type: "detected" | "resolved" | "reopened";
  event_at: string;
};

export type VulnerabilityRetestRecord = {
  id: number;
  vulnerability_id: string;
  server_id: string;
  status: "requested" | "passed" | "failed";
  requested_at: string;
  retested_at: string | null;
};

export function countVulnerabilities() {
  const row = db
    .prepare<{ total: number }>("SELECT COUNT(*) as total FROM vulnerabilities")
    .get();
  return row?.total ?? 0;
}

export function listVulnerabilitiesByIds(ids: string[]) {
  if (!Array.isArray(ids) || ids.length === 0) return [];
  const placeholders = ids.map(() => "?").join(", ");
  return db
    .prepare<VulnerabilityRecord>(
      `SELECT id, title, severity, description, observations, remediation, affected, score,
              cve, cpe, vpr_score, vpr_updated, cvss4_base_score, cvss4_temporal_score,
              cvss3_base_score, cvss3_temporal_score, cvss_temporal_score
       FROM vulnerabilities
       WHERE id IN (${placeholders})
       ORDER BY id`
    )
    .all(...ids);
}

export function listVulnerabilities(limit?: number, offset?: number) {
  const hasLimit = typeof limit === "number" && Number.isFinite(limit);
  const hasOffset = typeof offset === "number" && Number.isFinite(offset);
  const clause = hasLimit ? "LIMIT ? OFFSET ?" : "";
  return db
    .prepare<VulnerabilityRecord>(
      `SELECT id, title, severity, description, observations, remediation, affected, score,
              cve, cpe, vpr_score, vpr_updated, cvss4_base_score, cvss4_temporal_score,
              cvss3_base_score, cvss3_temporal_score, cvss_temporal_score
       FROM vulnerabilities
       ORDER BY id
       ${clause}`
    )
    .all(...(hasLimit ? [Math.max(0, Math.round(limit!)), Math.max(0, Math.round(offset ?? 0))] : []));
}

export function listVulnerabilityServers(ids?: string[]) {
  if (Array.isArray(ids) && ids.length > 0) {
    const placeholders = ids.map(() => "?").join(", ");
    return db
      .prepare<VulnerabilityServerRecord>(
        `SELECT id, name, ip, environment, asset_class
         FROM vulnerability_servers
         WHERE id IN (${placeholders})
         ORDER BY id`
      )
      .all(...ids);
  }
  return db
    .prepare<VulnerabilityServerRecord>(
      `SELECT id, name, ip, environment, asset_class
       FROM vulnerability_servers
       ORDER BY id`
    )
    .all();
}

export function countVulnerabilityServers() {
  const row = db
    .prepare<{ total: number }>("SELECT COUNT(*) as total FROM vulnerability_servers")
    .get();
  return row?.total ?? 0;
}

export function listVulnerabilityServersPaginated(limit: number, offset: number) {
  return db
    .prepare<VulnerabilityServerRecord>(
      `SELECT id, name, ip, environment, asset_class
       FROM vulnerability_servers
       ORDER BY id
       LIMIT ? OFFSET ?`
    )
    .all(Math.max(0, Math.round(limit)), Math.max(0, Math.round(offset)));
}

export function listVulnerabilityLinksByServerIds(serverIds: string[]) {
  if (!Array.isArray(serverIds) || serverIds.length === 0) return [];
  const placeholders = serverIds.map(() => "?").join(", ");
  return db
    .prepare<VulnerabilityLinkRecord>(
      `SELECT id, vulnerability_id, server_id, status, occurrences, resolved_count,
              first_detected_at, last_changed_at
       FROM vulnerability_links
       WHERE server_id IN (${placeholders})
       ORDER BY server_id, vulnerability_id`
    )
    .all(...serverIds);
}

export function updateVulnerabilityServerClass(id: string, assetClass: string) {
  db.prepare(
    `UPDATE vulnerability_servers SET asset_class = ? WHERE id = ?`
  ).run(assetClass, id);
}

export function upsertVulnerabilityServer(input: {
  id: string;
  name: string;
  ip: string;
  environment?: string | null;
  assetClass?: string | null;
}) {
  const exists = db
    .prepare<{ total: number }>(
      "SELECT COUNT(*) as total FROM vulnerability_servers WHERE id = ?"
    )
    .get(input.id);
  if ((exists?.total ?? 0) === 0) {
    db.prepare(
      `INSERT INTO vulnerability_servers (id, name, ip, environment, asset_class)
       VALUES (?, ?, ?, ?, ?)`
    ).run(
      input.id,
      input.name,
      input.ip,
      input.environment ?? null,
      input.assetClass ?? null
    );
    return;
  }
  db.prepare(
    `UPDATE vulnerability_servers
     SET name = ?, ip = ?, environment = ?, asset_class = COALESCE(?, asset_class)
     WHERE id = ?`
  ).run(
    input.name,
    input.ip,
    input.environment ?? null,
    input.assetClass ?? null,
    input.id
  );
}


export function listVulnerabilityLinks(vulnerabilityIds?: string[]) {
  if (Array.isArray(vulnerabilityIds) && vulnerabilityIds.length > 0) {
    const placeholders = vulnerabilityIds.map(() => "?").join(", ");
    return db
      .prepare<VulnerabilityLinkRecord>(
        `SELECT id, vulnerability_id, server_id, status, occurrences, resolved_count,
                first_detected_at, last_changed_at
         FROM vulnerability_links
         WHERE vulnerability_id IN (${placeholders})
         ORDER BY vulnerability_id, server_id`
      )
      .all(...vulnerabilityIds);
  }
  return db
    .prepare<VulnerabilityLinkRecord>(
      `SELECT id, vulnerability_id, server_id, status, occurrences, resolved_count,
              first_detected_at, last_changed_at
       FROM vulnerability_links
       ORDER BY vulnerability_id, server_id`
    )
    .all();
}

export function countVulnerabilityLinks() {
  const row = db
    .prepare<{ total: number }>("SELECT COUNT(*) as total FROM vulnerability_links")
    .get();
  return row?.total ?? 0;
}

export function listVulnerabilityLinksPaginated(limit: number, offset: number) {
  return db
    .prepare<VulnerabilityLinkRecord>(
      `SELECT id, vulnerability_id, server_id, status, occurrences, resolved_count,
              first_detected_at, last_changed_at
       FROM vulnerability_links
       ORDER BY vulnerability_id, server_id
       LIMIT ? OFFSET ?`
    )
    .all(Math.max(0, Math.round(limit)), Math.max(0, Math.round(offset)));
}

export function listVulnerabilityEvents(vulnerabilityIds?: string[]) {
  if (Array.isArray(vulnerabilityIds) && vulnerabilityIds.length > 0) {
    const placeholders = vulnerabilityIds.map(() => "?").join(", ");
    return db
      .prepare<VulnerabilityEventRecord>(
        `SELECT id, vulnerability_id, server_id, event_type, event_at
         FROM vulnerability_link_events
         WHERE vulnerability_id IN (${placeholders})
         ORDER BY event_at`
      )
      .all(...vulnerabilityIds);
  }
  return db
    .prepare<VulnerabilityEventRecord>(
      `SELECT id, vulnerability_id, server_id, event_type, event_at
       FROM vulnerability_link_events
       ORDER BY event_at`
    )
    .all();
}

export function listVulnerabilityRetests(vulnerabilityIds?: string[]) {
  if (Array.isArray(vulnerabilityIds) && vulnerabilityIds.length > 0) {
    const placeholders = vulnerabilityIds.map(() => "?").join(", ");
    return db
      .prepare<VulnerabilityRetestRecord>(
        `SELECT id, vulnerability_id, server_id, status, requested_at, retested_at
         FROM vulnerability_retests
         WHERE vulnerability_id IN (${placeholders})
         ORDER BY requested_at`
      )
      .all(...vulnerabilityIds);
  }
  return db
    .prepare<VulnerabilityRetestRecord>(
      `SELECT id, vulnerability_id, server_id, status, requested_at, retested_at
       FROM vulnerability_retests
       ORDER BY requested_at`
    )
    .all();
}

function getVulnerabilityLink(vulnerabilityId: string, serverId: string) {
  return db
    .prepare<VulnerabilityLinkRecord>(
      `SELECT id, vulnerability_id, server_id, status, occurrences, resolved_count,
              first_detected_at, last_changed_at
       FROM vulnerability_links
       WHERE vulnerability_id = ? AND server_id = ?`
    )
    .get(vulnerabilityId, serverId);
}

function getLatestRetest(vulnerabilityId: string, serverId: string) {
  return db
    .prepare<VulnerabilityRetestRecord>(
      `SELECT id, vulnerability_id, server_id, status, requested_at, retested_at
       FROM vulnerability_retests
       WHERE vulnerability_id = ? AND server_id = ?
       ORDER BY requested_at DESC
       LIMIT 1`
    )
    .get(vulnerabilityId, serverId);
}

function getLatestPendingRetest(vulnerabilityId: string, serverId: string) {
  return db
    .prepare<VulnerabilityRetestRecord>(
      `SELECT id, vulnerability_id, server_id, status, requested_at, retested_at
       FROM vulnerability_retests
       WHERE vulnerability_id = ? AND server_id = ? AND status = 'requested'
       ORDER BY requested_at DESC
       LIMIT 1`
    )
    .get(vulnerabilityId, serverId);
}

function ensureVulnerabilityExists(id: string) {
  const row = db
    .prepare<{ total: number }>(
      "SELECT COUNT(*) as total FROM vulnerabilities WHERE id = ?"
    )
    .get(id);
  return (row?.total ?? 0) > 0;
}

function ensureServerExists(id: string) {
  const row = db
    .prepare<{ total: number }>(
      "SELECT COUNT(*) as total FROM vulnerability_servers WHERE id = ?"
    )
    .get(id);
  return (row?.total ?? 0) > 0;
}

export function linkVulnerabilityToServer(
  vulnerabilityId: string,
  serverId: string
) {
  if (!ensureVulnerabilityExists(vulnerabilityId) || !ensureServerExists(serverId)) {
    return null;
  }

  const now = getLocalTimestamp();
  const current = getVulnerabilityLink(vulnerabilityId, serverId);
  const insertEvent = db.prepare(
    `INSERT INTO vulnerability_link_events
      (vulnerability_id, server_id, event_type, event_at)
      VALUES (?, ?, ?, ?)`
  );

  if (!current) {
    db.prepare(
      `INSERT INTO vulnerability_links
        (vulnerability_id, server_id, status, occurrences, resolved_count, first_detected_at, last_changed_at)
        VALUES (?, ?, 'active', 1, 0, ?, ?)`
    ).run(vulnerabilityId, serverId, now, now);
    insertEvent.run(vulnerabilityId, serverId, "detected", now);
    return getVulnerabilityLink(vulnerabilityId, serverId);
  }

  if (current.status === "resolved") {
    db.prepare(
      `UPDATE vulnerability_links
       SET status = 'active',
           occurrences = occurrences + 1,
           last_changed_at = ?
       WHERE id = ?`
    ).run(now, current.id);
    insertEvent.run(vulnerabilityId, serverId, "reopened", now);
  }

  return getVulnerabilityLink(vulnerabilityId, serverId);
}

export function resolveVulnerabilityForServer(
  vulnerabilityId: string,
  serverId: string
) {
  const now = getLocalTimestamp();
  const current = getVulnerabilityLink(vulnerabilityId, serverId);
  if (!current) {
    return null;
  }
  if (current.status === "resolved") {
    return current;
  }
  db.prepare(
    `UPDATE vulnerability_links
     SET status = 'resolved',
         resolved_count = resolved_count + 1,
         last_changed_at = ?
     WHERE id = ?`
  ).run(now, current.id);
  db.prepare(
    `INSERT INTO vulnerability_link_events
      (vulnerability_id, server_id, event_type, event_at)
      VALUES (?, ?, 'resolved', ?)`
  ).run(vulnerabilityId, serverId, now);
  return getVulnerabilityLink(vulnerabilityId, serverId);
}

export function requestVulnerabilityRetest(
  vulnerabilityId: string,
  serverId: string
) {
  const current = getVulnerabilityLink(vulnerabilityId, serverId);
  if (!current) {
    return null;
  }
  const now = getLocalTimestamp();
  db.prepare(
    `INSERT INTO vulnerability_retests
      (vulnerability_id, server_id, status, requested_at)
      VALUES (?, ?, 'requested', ?)`
  ).run(vulnerabilityId, serverId, now);
  return getLatestRetest(vulnerabilityId, serverId);
}

export function completeVulnerabilityRetest(
  vulnerabilityId: string,
  serverId: string,
  result: "passed" | "failed"
) {
  const current = getVulnerabilityLink(vulnerabilityId, serverId);
  if (!current) {
    return null;
  }
  const now = getLocalTimestamp();
  const pending = getLatestPendingRetest(vulnerabilityId, serverId);
  if (pending) {
    db.prepare(
      `UPDATE vulnerability_retests
       SET status = ?, retested_at = ?
       WHERE id = ?`
    ).run(result, now, pending.id);
  } else {
    db.prepare(
      `INSERT INTO vulnerability_retests
        (vulnerability_id, server_id, status, requested_at, retested_at)
        VALUES (?, ?, ?, ?, ?)`
    ).run(vulnerabilityId, serverId, result, now, now);
  }

  if (result === "passed") {
    resolveVulnerabilityForServer(vulnerabilityId, serverId);
  }

  return getLatestRetest(vulnerabilityId, serverId);
}

export function listEventsForLink(vulnerabilityId: string, serverId: string) {
  return db
    .prepare<VulnerabilityEventRecord>(
      `SELECT id, vulnerability_id, server_id, event_type, event_at
       FROM vulnerability_link_events
       WHERE vulnerability_id = ? AND server_id = ?
       ORDER BY event_at`
    )
    .all(vulnerabilityId, serverId);
}
